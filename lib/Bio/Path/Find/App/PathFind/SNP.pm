
package Bio::Path::Find::App::PathFind::SNP;

# ABSTRACT: Find VCF files for lanes

use v5.10; # for "say"

use MooseX::App::Command;
use namespace::autoclean;
use MooseX::StrictConstructor;

use Carp qw ( carp );
use Path::Class;
use Try::Tiny;
use DateTime;

use Types::Standard qw(
  ArrayRef
  Str
  +Bool
);

use Bio::Path::Find::Types qw( :types MappersFromMapper );

use Bio::Path::Find::Exception;
use Bio::Path::Find::RefFinder;
use Bio::Path::Find::Lane::Class::SNP;

extends 'Bio::Path::Find::App::PathFind';

with 'Bio::Path::Find::App::Role::Archivist',
     'Bio::Path::Find::App::Role::Linker';

#-------------------------------------------------------------------------------
#- usage text ------------------------------------------------------------------
#-------------------------------------------------------------------------------

# this is used when the "pf" app class builds the list of available commands
command_short_description 'Find VCF files for lanes';

# the module POD is used when the users runs "pf man snp"

=head1 NAME

pf snp - Find VCF files for lanes

=head1 USAGE

  pf snp --id <id> --type <ID type> [options]

=head1 DESCRIPTION

This pathfind command will return information about mapped assemblies.  Specify
the type of data using C<--type> and give the accession, name or identifier for
the data using C<--id>.

Use "pf man" or "pf man info" to see more information.

=head1 EXAMPLES

  # get a list of bam files for a lane
  pf map -t lane -i 12345_1#1

  # find bam files generated with bwa
  pf map -t lane -i 12345_1 -M bwa

  # find bam files generated by mapping against a specific reference
  pf map -t lane -i 12345_1 -R Streptococcus_suis_P1_7_v1

  # get details (reference, mapper, date) for bam files
  pf map -t lane -i 12345_1 -d

  # generate statistics for a set of mappings
  pf map -t study -i 123 -s study_123_stats.csv

  # create a tar file containing the bam files for a study
  pf map -t study -i 123 -a study_123_bam_files.tar.gz

=cut

=head1 OPTIONS

These are the options that are specific to C<pf map>. Run C<pf man> to see
information about the options that are common to all C<pf> commands.

=over

=item --details, -d

Show the details of each assembly.

=item --mapper, -M <mapper>

Only show bam files that were generated using the specified mapper(s). You can
specify multiple mappers by providing a comma-separated list. The name of the
mapper must be one of: C<bowtie2>, C<bwa>, C<bwa_aln>, C<smalt>, C<ssaha2>,
C<stampy>, C<tophat>.

=item --reference, -R <reference genome>

Only show files generated by mapping against a specific reference genome. The
name of the genome must be exact; use C<pf ref -R> to find the name of a
reference.

=item --stats, -s [<stats filename>]

Write a file with statistics about found mappings. Save to specified filename,
if given.

=item --symlink, -l [<symlink directory>]

Create symlinks to found data. Create links in the specified directory, if
given, or in the current working directory.

=item --archive, -a [<tar filename>}

Create a tar archive containing the found bam files. Save to the specified
filename, if given

=item --no-tar-compression, -u

Don't compress tar archives.

=item --zip, -z [<zip filename>]

Create a zip archive containing data files for found lanes. Save to
specified filename, if given.

=item --rename, -r

Rename filenames when creating archives or symlinks, replacing hashed
(#) with underscores (_).

=back

=cut

=head1 SCENARIOS

=head2 Find mapped assemblies

The default behaviour of the C<pf map> command is to print the paths to
bam files for a set of lanes:

  pf map -t lane -i 12345_1#1

You can also see a few more details about each mapping, using the C<--details>
(C<-d>) option:

  pf map -t lane -i 12345_1#1 -d
  /scratch/pathogen/prokaryotes/seq-pipelines/Escherichia/coli/TRACKING/3893STDY6199423/SLX/15100687/12345_1#27/593103.pe.markdup.bam        Escherichia_coli_ST131_strain_EC958_v1  smalt   2016-03-19T14:52:19

The output now includes four tab-separated columns for each file, giving:

=over

=item full file path

=item reference genome that was used during mapping

=item name of the mapping software used

=item creation date of the mapping

=back

=head2 Show mappings generated by a specific mapper

You can filter the list of returned files in a couple of ways. Some lanes will
be mapped using multiple mappers, so you can specify which mapping program you
need using the C<--mapper> (C<-M>) option:

  pf map -t lane -i 12345_1 -M bwa

You will now see only mappings generated using C<bwa>. If you want to see
mappings generated by more than one mapper, you can use a comma-separated list
of mappers:

  pf map -t lane -i 12345_1 -M bwa,smalt

or you can use the C<-M> option multiple times:

  pf map -t lane -i 12345_1 -M bwa -M smalt

=head2 Show mappings that use a specific reference genome

You can also filter the list of bam files according to which reference
genome they use:

  pf map -t lane -i 12345_1 -R Escherichia_coli_NA114_v2

You can only specify one reference at a time.

The name of the reference must be given exactly. You can find the full, exact
name for a reference using C<pf ref>:

  % pf ref -i Eschericia_coli -R
  Escherichia_coli_0127_H6_E2348_69_v1
  Escherichia_coli_042_v1
  Escherichia_coli_9000_v0.1
  ...

=head2 Archive or link the found files

You can generate a tar file or a zip file containing all of the bam files that
are found:

  pf map -t lane -i 12345_1 -a bams.tar.gz

or

  pf map -t lane -i 12345_1 -z bams.zip

Alternatively, you can create symlinks to the files in a directory of your
choice:

  pf map -t lane -i 12345_1 -l bam_files

=cut

#-------------------------------------------------------------------------------
#- command line options --------------------------------------------------------
#-------------------------------------------------------------------------------

option 'filetype' => (
  documentation => 'type of files to find',
  is            => 'ro',
  isa           => SNPType,
  cmd_aliases   => 'f',
  default       => 'vcf',
);

option 'details' => (
  documentation => 'show details for each mapping run',
  is            => 'ro',
  isa           => Bool,
  cmd_aliases   => 'd',
);

option 'qc' => (
  documentation => 'filter results by lane QC state',
  is            => 'ro',
  isa           => QCState,
  cmd_aliases   => 'q',
);

option 'reference' => (
  documentation => 'show lanes that were mapped against a specific reference',
  is            => 'ro',
  isa           => Str,
  cmd_aliases   => 'R',
);

option 'mapper' => (
  documentation => 'show assemblies mapped with specific mapper(s)',
  is            => 'rw',
  isa           => Mappers->plus_coercions(MappersFromMapper),
  coerce        => 1,
  cmd_aliases   => 'M',
  cmd_split     => qr/,/,
);

option 'exclude_reference' => (
  documentation => 'exclude the reference when generating a pseudogenome',
  is            => 'rw',
  isa           => Bool,
  cmd_aliases   => 'x',
  cmd_flag      => 'exclude-reference',
);

#---------------------------------------

# this option can be used as a simple switch ("-p") or with an argument
# ("-p myfile"). It's a bit fiddly to set that up...

option 'pseudogenome' => (
  documentation => 'generate a pseudogenome',
  is            => 'rw',
  isa           => Bool,
  cmd_aliases   => 'p',
  # trigger       => \&_check_for_pg_value,
  # no "isa" because we want to accept both Bool and Str and it doesn't seem to
  # be possible to specify that using the combination of MooseX::App and
  # Type::Tiny that we're using here
);

# set up a trigger that checks for the value of the "pseudogenome" command-line
# argument and tries to decide if it's a boolean, in which case we'll generate
# a filename, or a string, in which case we'll treat that string as a filename.
# sub _check_for_pg_value {
#   my ( $self, $new, $old ) = @_;
#
#   if ( not defined $new ) {
#     # write pseudogenome to default file
#     $self->_pseudogenome_flag(1);
#
#     if ( not defined $self->reference and
#          not $self->exclude_reference ) {
#       Bio::Path::Find::Exception->throw(
#         msg => 'ERROR: when building a pseudogenome you must either specify a reference or use the "--exclude-reference" option'
#       );
#     }
#
#     # set the default file name
#     my $filename = $self->_renamed_id;
#     if ( $self->exclude_reference ) {
#       $filename .=  '_concatenated.aln';
#     }
#     else {
#       $filename .=  '_' . $self->reference . '_concatenated.aln';
#     }
#     $self->_pseudogenome( file $filename );
#   }
#   elsif ( not is_Bool($new) ) {
#     # write pseudogenome to file specified by the user
#     $self->_pseudogenome_flag(1);
#     $self->_pseudogenome( file $new );
#   }
#   else {
#     # don't write file. Shouldn't ever get here
#     $self->_pseudogenome_flag(0);
#   }
# }

#-------------------------------------------------------------------------------
#- private attributes ----------------------------------------------------------
#-------------------------------------------------------------------------------

# private attributes to store the (optional) value of the "pseudogenome"
# attribute.  When using all of this we can check for "_pseudogenome_flag"
# being true or false, and, if it's true, check "_pseudogenome" for a value
# has '_pseudogenome'      => ( is => 'rw', isa => PathClassFile, default => sub { file 'qc_summary.csv' } );
# has '_pseudogenome_flag' => ( is => 'rw', isa => Bool );

#---------------------------------------

has '_ref_finder' => (
  is      => 'ro',
  isa     => BioPathFindRefFinder,
  builder => '_build_ref_finder',
  lazy    => 1,
);

sub _build_ref_finder {
  return Bio::Path::Find::RefFinder->new;
}

#-------------------------------------------------------------------------------
#- builders --------------------------------------------------------------------
#-------------------------------------------------------------------------------

# this is a builder for the "_lane_class" attribute, which is defined on the
# parent class, B::P::F::A::PathFind. The return value specifies the class of
# object that should be returned by the B::P::F::Finder::find_lanes method.

sub _build_lane_class {
  return 'Bio::Path::Find::Lane::Class::SNP';
}

#-------------------------------------------------------------------------------
#- public methods --------------------------------------------------------------
#-------------------------------------------------------------------------------

sub run {
  my $self = shift;

  # TODO fail fast if we're going to overwrite something
  # if ( $self->_pseudogenome_flag and
  #      -e $self->_pseudogenome   and
  #      not $self->force ) {
  #   Bio::Path::Find::Exception->throw(
  #     msg => q(ERROR: output file ") . $self->_pseudogenome
  #            . q(" already exists; not overwriting. Use "-F" to force overwriting)
  #   );
  # }

  # build the parameters for the finder
  my %finder_params = (
    ids      => $self->_ids,
    type     => $self->_type,
  );

  # if we're building a pseudogenome, we need to collect the pseudogenome
  # files for each lane, so override whatever value we have for filetype and
  # force the lanes to return "pseudo_genome.fasta" files.
  $finder_params{filetype} = $self->pseudogenome
                           ? 'pseudogenome'
                           : $self->filetype;

  #---------------------------------------

  # these are filters that are applied by the finder

  # when finding lanes, should the finder filter on QC status ?
  $finder_params{qc} = $self->qc if $self->qc;

  # should we look for lanes with the "snp_called" bit set on the "processed"
  # bit field ? Turning this off, i.e. setting the command line option
  # "--ignore-processed-flag", will allow the command to return data for lanes
  # that haven't completed the SNP calling pipeline.
  $finder_params{processed} = Bio::Path::Find::Types::SNP_CALLED_PIPELINE
    unless $self->ignore_processed_flag;

  #---------------------------------------

  # these are filters that are applied by the lanes themselves, when they're
  # finding files to return (see "B::P::F::Lane::Class::Map::_get_bam")

  # when finding files, should the lane restrict the results to files created
  # with a specified mapper ?
  $finder_params{lane_attributes}->{mappers} = $self->mapper
    if $self->mapper;

  # when finding files, should the lane restrict the results to mappings
  # against a specific reference ?
  $finder_params{lane_attributes}->{reference} = $self->reference
    if $self->reference;

  #---------------------------------------

  # find lanes
  my $lanes = $self->_finder->find_lanes(%finder_params);

  if ( scalar @$lanes < 1 ) {
    say STDERR 'No data found.';
    return;
  }

  if ( $self->pseudogenome ) {
    $self->_create_pseudogenomes($lanes);
  }
  elsif ( $self->_symlink_flag or
       $self->_tar_flag or
       $self->_zip_flag ) {
    # do something with the found lanes
    $self->_make_symlinks($lanes) if $self->_symlink_flag;
    $self->_make_tar($lanes)      if $self->_tar_flag;
    $self->_make_zip($lanes)      if $self->_zip_flag;
  }
  else {
    # print the list of files. Should we show extra info ?
    if ( $self->details ) {
      # yes; print file path, reference, mapper and timestamp
      $_->print_details for @$lanes;
    }
    else {
      # no; just print the paths
      $_->print_paths for @$lanes;
    }
  }
}

#-------------------------------------------------------------------------------
#- private methods -------------------------------------------------------------
#-------------------------------------------------------------------------------

sub _create_pseudogenomes {
  my ( $self, $lanes ) = @_;

  my $references = $self->_collect_sequences($lanes);
  $self->_write_pseudogenomes($references);
}

#-------------------------------------------------------------------------------

# generate a list of the pseudogenome fasta files for the set of lanes

sub _collect_sequences {
  my ( $self, $lanes ) = @_;

  my %references;
  LANE: foreach my $lane ( @$lanes ) {

    # for each lane, collect the most recent sequence file for each reference
    my %latest_sequence_files;

    # walk over the list of files for this lane. There may be multiple mappings
    # and therefore multiple sequence files. Work out which one to return
    FILE: foreach my $pg_fasta ( $lane->all_files ) {

      # if a file should exist but doesn't, the user will get a warning from
      # the finder. Here we'll just skip it.
      next unless -f $pg_fasta;

      # collect together the details of the current file
      my $file_info = $lane->get_file_info($pg_fasta);
      my $file_hash = {
        file      => $pg_fasta,        # this file...
        lane      => $lane,            # from this lane...
        ref       => $file_info->[0],  # was mapped against this reference...
        mapper    => $file_info->[1],  # using this mapper...
        timestamp => $file_info->[2],  # at this time
      };

      # if we haven't got a file for this reference yet, or if the current file
      # is newer than the previous file, keep this file
      my $ref = $file_hash->{ref};
      if ( not defined $latest_sequence_files{$ref} or
           DateTime->compare($file_hash->{timestamp}, $latest_sequence_files{$ref}->{timestamp} ) > 0 ) {
        $latest_sequence_files{$ref} = $file_hash;
      }
    }

    # store the files for this lane. The result is a hash, keyed on the name of
    # the reference, with a file info hash as the value.
    foreach my $ref ( keys %latest_sequence_files ) {
      push @{ $references{$ref} }, $latest_sequence_files{$ref};
    }
  }

  return \%references;
}

#-------------------------------------------------------------------------------

# generate sequence files for the pseudogenomes

sub _write_pseudogenomes {
  my ( $self, $references ) = @_;

  say "omitting reference sequences from pseudogenomes"
    if $self->exclude_reference;

  my $pb = $self->_create_pb( 'building pseudogenomes', scalar keys %$references );

  # keep track of the files that we actually write
  my @written_files;

  REFERENCE: while ( my ( $reference, $files ) = each %$references ) {

    # get the path to the fasta file containing the reference genome sequence
    my $ref_path = $self->_get_reference_path($reference);

    # generate the filename for the pseudogenome sequence alignment file
    my $pg_filename = $self->_renamed_id . "_${reference}_concatenated.aln";

    # make sure we're not overwriting anything without permission
    if ( -e $pg_filename and not $self->force ) {
      Bio::Path::Find::Exception->throw(
        msg => qq(ERROR: output file "$pg_filename" already exists; not overwriting. Use "-F" to force overwriting)
      );
    }

    # open the output file
    open PSEUDOGENOME, '>', $pg_filename
      or Bio::Path::Find::Exception->throw(
        msg => qq(ERROR: couldn't write the pseudogenome to file "$pg_filename": $!)
      );

    # should we add the reference sequence ?
    if ( not $self->exclude_reference ) {
      open REFERENCE, '<', $ref_path
        or Bio::Path::Find::Exception->throw(
          msg => qq(ERROR: couldn't read the reference genome sequence from "$ref_path": $!)
        );
      say PSEUDOGENOME ">$reference";
      for ( grep { ! m/^\>/ } <REFERENCE> ) {
        print PSEUDOGENOME $_;
      }
      close REFERENCE;
    }

    # add the sequences
    FILE: foreach my $file ( @$files ) {
      unless ( open PG_FILE, '<', $file->{file} ) {
        carp q(WARNING: couldn't read the pseudogenome sequence file for lane ")
               . $file->{lane}->row->name . q|" (file "| . $file->{file}
               . qq|"): $!|;
        next FILE;
      }
      while ( <PG_FILE> ) { print PSEUDOGENOME $_ }
      close PG_FILE;
    }
    push @written_files, $pg_filename;

    $pb++;
  }

  say qq(wrote "$_") for @written_files;
}

#-------------------------------------------------------------------------------

# given the name of a reference genome, find the path to its sequence file

sub _get_reference_path {
  my ( $self, $ref ) = @_;

  # find the path to the reference
  my $refs = $self->_ref_finder->lookup_paths( [ $ref ], 'fa' );

  # make sure we have one, and only one, file path
  if ( not scalar @$refs ) {
    Bio::Path::Find::Exception->throw(
      msg => qq(ERROR: can't find reference genome "$ref"; try looking it up using "pf ref"),
    );
  }
  if ( scalar @$refs > 1 ) {
    # we shouldn't ever get here. The reference name is used to filter lanes,
    # so if the supplied name isn't unique, it won't match the reference used
    # when mapping the lanes, so we won't *have* any lanes.
    Bio::Path::Find::Exception->throw(
      msg => q(ERROR: reference genome name is ambiguous; try looking it up using "pf ref"),
    );
  }

  return $refs->[0];
}

#-------------------------------------------------------------------------------

__PACKAGE__->meta->make_immutable;

1;

